{"version":3,"sources":["../src/actions/SetProperty.ts","../src/actions/GetProperty.ts","../src/actions/EvalProperty.ts","../src/actions/FilterProperty.ts","../src/PropertyReformer.ts","../src/ObjectReformer.ts","../src/ParseModel.ts"],"sourcesContent":["\nimport { PropertyStatus, Property } from '../ReformerModel';\n\nfunction SetProperty(input: any, property: Property, newValue: any): PropertyStatus {\n    let current: any = input;\n    try {\n        const keys = property.split(\".\");\n        \n        keys.forEach((key, index) => {\n            const match = key.match(/(.+?)\\[(\\d+)]/);\n            \n            if (match) {\n                const [_, arrayKey, arrayIndex] = match;\n                const idx = Number(arrayIndex);\n                \n                current[arrayKey] ??= [];\n                if (!Array.isArray(current[arrayKey])) {\n                    throw new Error(`${arrayKey} is not an array`);\n                }\n\n                current = (index === keys.length - 1) \n                    ? (current[arrayKey][idx] = newValue) \n                    : (current[arrayKey][idx] ??= {});\n            } else {\n                current = (index === keys.length - 1) \n                    ? (current[key] = newValue) \n                    : (current[key] ??= {});\n            }\n        });\n        return null;\n    } catch (error: any) {\n        return error;\n    }\n}\n\nexport default SetProperty;","\nimport { ScriptArray, PropertyStatus, Property } from '../ReformerModel';\n\nfunction GetProperty(input: any, property: Property): any {\n    const keys = property.split(\".\");\n    let current: any = input;\n\n    for (const key of keys) {\n    const arrayMatch = key.match(/(.+?)\\[(\\d+)]/); // Check for array access like \"array[1]\"\n    if (arrayMatch) {\n        const arrayKey = arrayMatch[1];\n        const index = parseInt(arrayMatch[2], 10);\n        current = current[arrayKey];\n        if (!Array.isArray(current)) {\n        throw new Error(`${arrayKey} is not an array`);\n        }\n        current = current[index];\n    } else {\n        current = current[key];\n    }\n\n    if (current === undefined) {\n        throw new Error(`Key path \"${property}\" does not exist`);\n    }\n    }\n\n    return current;\n}\n\nexport default GetProperty;","import { ScriptArray, PropertyStatus, Property } from '../ReformerModel';\nimport SetProperty from './SetProperty';\nimport GetProperty from './GetProperty';\n\n/// <summary>\n/// Set a property value in a nested object, given a key path using value from script.\n/// </summary>\nfunction EvalProperty(input: any, property: Property, newValue: any, scripts: ScriptArray): PropertyStatus {\n    try {\n        const propertyPath = property\n            .replace(/\\[(\\d+)]/g, \".$1\") // Convert array indices to dot notation\n            .split(\".\")\n            .map(key => (/^\\d+$/.test(key) ? `[${key}]` : `.${key}`))\n            .join(\"\")\n            .replace(/^\\./, \"\"); // Ensure no leading dot for eval;\n\n        if (!scripts || scripts.length === 0) {\n            throw new Error('Scripts array is undefined or empty');\n        }\n\n        const currentValue = GetProperty(input, propertyPath);\n        scripts?.forEach(({ action, parameters, body }) => {\n            const evalProperty = new Function('input', 'property', 'currentValue', 'newValue', body);\n            const result = evalProperty(input, propertyPath, currentValue, newValue);\n            SetProperty(input, property, result);\n        });\n        return null;\n    } catch (error: any) {\n        return error;\n    }\n}\n\nexport default EvalProperty;","import { PropertyStatus, Property, ScriptArray } from '../ReformerModel';\nimport SetProperty from './SetProperty';\nimport GetProperty from './GetProperty';\n\n// Extend the Array interface to include our custom methods\ndeclare global {\n    interface Array<T> {\n        select<U>(selector: (item: T) => U): U[];\n        where(predicate: (item: T) => boolean): T[];\n        orderBy(selector: (item: T) => any[]): T[];\n    }\n}\n\n// Implement the custom methods on the Array prototype\nif (!Array.prototype.select) {\n    Array.prototype.select = function <T, U>(this: T[], selector: (item: T) => U): U[] {\n        return this.map(selector);\n    };\n}\n\nif (!Array.prototype.where) {\n    Array.prototype.where = function <T>(this: T[], predicate: (item: T) => boolean): T[] {\n        return this.filter(predicate);\n    };\n}\n\nif (!Array.prototype.orderBy) {\n    Array.prototype.orderBy = function <T>(this: T[], selector: (item: T) => any[]): T[] {\n        return [...this].sort((a, b) => {\n        const keyA = selector(a);\n        const keyB = selector(b);\n        // Compare each element of the key arrays in order\n        for (let i = 0; i < Math.max(keyA.length, keyB.length); i++) {\n            const valA = keyA[i];\n            const valB = keyB[i];\n            if (valA === valB) continue;\n            return valA < valB ? -1 : 1;\n        }\n        return 0;\n        });\n    };\n}\n\n// Function that applies the query string on a given array.\n// It uses the Function constructor to create a new function that takes an array ('arr')\n// and returns the result of chaining the provided query string to it.\nfunction applyQuery<T>(arr: T[], query: string): any[] {\n    const queryFunction = new Function('arr', 'return arr' + query + ';');\n    return queryFunction(arr);\n}\n\nexport function FilterProperty(input: any, property: Property, scripts: ScriptArray): PropertyStatus {\n    try {\n        const propertyPath = property\n            .replace(/\\[(\\d+)]/g, \".$1\") // Convert array indices to dot notation\n            .split(\".\")\n            .map(key => (/^\\d+$/.test(key) ? `[${key}]` : `.${key}`))\n            .join(\"\")\n            .replace(/^\\./, \"\"); // Ensure no leading dot for eval;\n\n        if (!scripts || scripts.length === 0) {\n            throw new Error('Scripts array is undefined or empty');\n        }\n\n        const currentValue = GetProperty(input, propertyPath);\n        scripts?.forEach(({ action, parameters, body }) => {\n            const filteredArray = applyQuery(currentValue, body);\n            SetProperty(input, property, filteredArray);\n        });\n        return null;\n    } catch (error: any) {\n        return error;\n    }\n}\n\nexport {};\n","import { ScriptArray, Property, Reformer } from './ReformerModel';\nimport EvalProperty from './actions/EvalProperty';\nimport SetProperty from './actions/SetProperty';\nimport { FilterProperty } from './actions/FilterProperty';\n\nexport const PropertyReformer = (scripts: ScriptArray) => {\n\n    // assign scripts to local scripts property\n    const _scripts = scripts;\n\n    const reform = (reformer: Reformer, input: any, property: Property ) => {\n        const newValue = reformer[property];\n        const propertyScript = reformer.scripts ?? _scripts;\n\n        if (propertyScript) {\n            switch (propertyScript[0].action.toLowerCase()) {\n                case 'filter':\n                    return FilterProperty(input, property, propertyScript);\n                default:\n                    break;\n            }\n            return EvalProperty(input, property, newValue, propertyScript);\n        } \n        return SetProperty(input, property, newValue);\n    };\n\n    return {\n        reform\n    };\n};\n\nexport default PropertyReformer;","import ReformerModel, { ReformersStatus} from './ReformerModel';\nimport PropertyReformer from './PropertyReformer';\n/// <summary>\n/// ObjectReformer module to \n/// </summary>\nexport const ObjectReformer = (model: ReformerModel) => {\n\n    // assign model to local Model property\n    const _model = model;\n\n    // Status of property in reformers\n    let _reformersStatus: ReformersStatus = new Map();\n\n    // assign reformProperty to local reformProperty property\n    const { reform : reformProperty } = PropertyReformer(model.scripts);\n\n    /// <summary>\n    /// Reform the input object according to the reformer model.\n    /// </summary>\n    const reform = (input: any) => {\n        try {\n            if (!input) {\n                throw new Error(\"Invalid input\");\n            }\n            \n            for (let reformer of _model.reformers) {\n                const propertyPath = Object.keys(reformer)[0];\n                // Skip if property is already reformed\n                if(_reformersStatus.has(propertyPath)) {\n                    continue;\n                }\n\n                const status = reformProperty(reformer, input, propertyPath);\n                _reformersStatus.set(propertyPath, status);\n            }\n            return input;\n        } catch (error: any) {\n            throw new Error(`Invalid JSON input:  ${error.message}` );\n        }\n    }\n\n    return {\n        reform,\n        status: _reformersStatus\n    };\n};","/**\n * Cleans up a JSON string by removing extra unused characters and\n * normalizing string literals so that newlines and extra whitespace\n * inside them are replaced with single spaces.\n *\n * @param jsonStr - The original JSON string.\n * @returns The cleaned JSON string, ready for JSON.parse.\n */\nexport const ParseModel = (jsonStr: string): string => {\n    // Step 1: Trim overall whitespace from the input.\n    const trimmed: string = jsonStr.trim();\n  \n    // Step 2: Extract the core JSON (from the first '{' or '[' to the last '}' or ']').\n    const startIndex: number = trimmed.search(/[\\{\\[]/);\n    const endIndex: number = Math.max(trimmed.lastIndexOf('}'), trimmed.lastIndexOf(']'));\n    if (startIndex === -1 || endIndex === -1) {\n      throw new Error(\"Invalid JSON structure.\");\n    }\n    const jsonCore: string = trimmed.substring(startIndex, endIndex + 1);\n  \n    // Step 3: Replace newlines and extra spaces inside JSON string literals.\n    // This regex matches any JSON string literal.\n    const fixed: string = jsonCore.replace(/\"((?:\\\\.|[^\"\\\\])*)\"/g, (match: string, content: string) => {\n      // Replace newline characters (and following whitespace) with a single space.\n      let cleanedContent: string = content.replace(/\\n\\s*/g, ' ');\n      // Collapse multiple spaces into one.\n      cleanedContent = cleanedContent.replace(/\\s{2,}/g, ' ');\n      // Trim any accidental leading/trailing spaces.\n      cleanedContent = cleanedContent.trim();\n      // Return the fixed string literal with surrounding quotes.\n      return `\"${cleanedContent}\"`;\n    });\n  \n    return fixed;\n  }\n"],"mappings":"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","names":["SetProperty","input","property","newValue","current","keys","key","index","_a","_b","_c","_d","match","_","arrayKey","arrayIndex","idx","error","SetProperty_default","GetProperty","input","property","keys","current","key","arrayMatch","arrayKey","index","GetProperty_default","EvalProperty","input","property","newValue","scripts","propertyPath","key","currentValue","GetProperty_default","action","parameters","body","result","SetProperty_default","error","EvalProperty_default","selector","predicate","a","b","keyA","keyB","i","valA","valB","applyQuery","arr","query","FilterProperty","input","property","scripts","propertyPath","key","currentValue","GetProperty_default","action","parameters","body","filteredArray","SetProperty_default","error","PropertyReformer","scripts","_scripts","reformer","input","property","_a","newValue","propertyScript","FilterProperty","EvalProperty_default","SetProperty_default","PropertyReformer_default","ObjectReformer","model","_model","_reformersStatus","reformProperty","PropertyReformer_default","input","reformer","propertyPath","status","error","ParseModel","jsonStr","trimmed","startIndex","endIndex","match","content","cleanedContent"]}